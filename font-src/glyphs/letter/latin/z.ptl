$$include '../../../meta/macros.ptl'

import [mix SuffixCfg fallback] from"../../../support/utils.mjs"
import [CvDecompose MathSansSerif] from"../../../support/gr.mjs"

glyph-module

glyph-block Letter-Latin-Z : begin
	glyph-block-import CommonShapes
	glyph-block-import Common-Derivatives
	glyph-block-import Mark-Adjustment : ExtendBelowBaseAnchors
	glyph-block-import Letter-Shared : CreateAccentedComposition
	glyph-block-import Letter-Shared-Shapes : HCurlyTail PalatalHook RetroflexHook CyrDescender
	glyph-block-import Letter-Blackboard : BBS BBD
	glyph-block-import Letter-Latin-X : XStrand

	define MODE-Z      0
	define MODE-RTAIL  1
	define MODE-ZDESC  2
	define MODE-ZSWASH 3

	define [DisplayBottomStroke mode] : not : mode === MODE-ZDESC || mode === MODE-ZSWASH

	define [ZSerifless top] : glyph-proc

	define [ZStdSerifs top] : glyph-proc
		include : tagged 'serifLT' : VSerif.dl SB top VJut
		include : tagged 'serifRB' : VSerif.ur RightSB 0 VJut

	define [ZMotionSerifsB top] : glyph-proc
		include : tagged 'serifRB' : VSerif.ur RightSB 0 VJut

	define [ZMotionSerifsT top] : glyph-proc
		include : tagged 'serifLT' : VSerif.dl SB top VJut

	define [ZBaseShape mode] : glyph-proc
		local cor : 1.15 * HVContrast
		include : tagged 'strokeTop' : HBar.t SB RightSB CAP
		include : spiro-outline
			corner SB [if (mode === MODE-ZSWASH) 0 Stroke]
			corner (RightSB - Stroke * cor) (CAP - Stroke)
			corner RightSB (CAP - Stroke)
			corner (SB + Stroke * cor) [if (mode === MODE-ZSWASH) 0 Stroke]
		if [DisplayBottomStroke mode] : include : tagged 'strokeBottom' : HBar.b SB RightSB 0

	define [ZCurlyShape mode] : glyph-proc
		include : tagged 'strokeTop' : HBar.t SB (RightSB - Stroke * HVContrast) CAP
		include : XStrand false SLAB SB 0 RightSB CAP 0.125 0.4 0.32
		if [DisplayBottomStroke mode] : include : tagged 'strokeBottom' : HBar.b (SB + Stroke * HVContrast) RightSB 0

	define [HBar.mOver] : refer-glyph 'barOver'
	define [DBarOver] : refer-glyph 'antiSlashOver'

	define [SmallZBaseShape mode] : glyph-proc
		local cor : 1.2 * HVContrast
		include : tagged 'strokeTop' : HBar.t SB RightSB XH
		include : spiro-outline
			corner SB [if (mode === MODE-ZSWASH) 0 Stroke]
			corner (RightSB - Stroke * cor) (XH - Stroke)
			corner RightSB (XH - Stroke)
			corner (SB + Stroke * cor) [if (mode === MODE-ZSWASH) 0 Stroke]
		if [DisplayBottomStroke mode] : include : tagged 'strokeBottom' : HBar.b SB RightSB 0
		set-base-anchor "trailing" RightSB 0

	define [SmallZCurlyShape mode] : glyph-proc
		include : tagged 'strokeTop' : HBar.t SB (RightSB - Stroke * HVContrast) XH
		include : XStrand false SLAB SB 0 RightSB XH 0.125 0.4 0.36
		if [DisplayBottomStroke mode] : include : tagged 'strokeBottom' : HBar.b (SB + Stroke * HVContrast) RightSB 0
		set-base-anchor "trailing" RightSB 0

	define [ZCursiveShapeImpl top mode] : glyph-proc
		define hookTerminalWidth : AdviceStroke 3.5
		define xDiagWidth : 1 * Stroke
		define yFootHeight : Math.max (0.15 * top) (Stroke * 0.625)
		define kFoot : 1 + 0.5 * Stroke / yFootHeight
		define yHookDepth : Hook + Stroke * 0.25
		define yHookStraightDepth : Math.min (yHookDepth - Stroke * 1.1) (yHookDepth / 3 - Stroke / 4)
		define xHookDepth : Math.max (0.25 * (RightSB - SB)) (hookTerminalWidth * 1.5)
		define xMockTailDepth : Math.max (0.375 * (RightSB - SB)) (hookTerminalWidth * 1.375)
		define kTop 0.625
		define kBot 0.625
		define yTailDepth : Hook * 0.5

		include : tagged 'strokeTop' : intersection
			spiro-outline
				corner SB 0
				corner (-Width) 0
				corner (-Width) (2 * top)
				corner (RightSB - xDiagWidth) (2 * top)
				corner (RightSB - xDiagWidth) (top - yFootHeight)
			dispiro
				flat (SB + OX) (top - yHookDepth) [widths.rhs.heading hookTerminalWidth Upward]
				curl (SB + OX) (top - yHookDepth + yHookStraightDepth) [heading Upward]
				arcvh
				g2.right.mid (SB + xHookDepth) (top - O) [widths.rhs.heading Stroke Rightward]
				flat [mix (SB + xMockTailDepth) RightSB kTop] (top - kTop * yTailDepth)
				curl RightSB                                  (top - yTailDepth)

		include : match mode
			[Just MODE-ZSWASH] : spiro-outline
				corner SB 0
				corner (RightSB - xDiagWidth) (top - yFootHeight)
				corner (RightSB - xDiagWidth) top
				corner RightSB top
				corner RightSB (top - kFoot * yFootHeight)
				corner (SB + xDiagWidth) 0
			__ : spiro-outline
				corner SB 0
				corner SB (kFoot * yFootHeight)
				corner (RightSB - xDiagWidth) (top - yFootHeight)
				corner (RightSB - xDiagWidth) top
				corner RightSB top
				corner RightSB (top - kFoot * yFootHeight)
				corner (SB + xDiagWidth) yFootHeight
				corner (SB + xDiagWidth) 0

		include : tagged 'strokeBottom' : match mode
			[Just MODE-RTAIL] : intersection
				spiro-outline
					corner (SB + xDiagWidth) yFootHeight
					corner (SB + xDiagWidth) (-top)
					corner (2 * Width) (-top)
					corner (2 * Width) (top)
					corner RightSB top

				union
					VBar.r RightSB 0 yHookDepth hookTerminalWidth
					dispiro
						flat  RightSB               O [widths.rhs.heading Stroke Leftward]
						g2  (RightSB - xHookDepth) O [widths.rhs.heading Stroke Leftward]
						flat [mix (RightSB - xHookDepth) SB kBot] (kBot * yTailDepth)
						curl SB                                   (yTailDepth)
			([Just MODE-ZDESC] || [Just MODE-ZSWASH]) : no-shape
			__ : intersection
				spiro-outline
					corner (SB + xDiagWidth) yFootHeight
					corner (SB + xDiagWidth) (-top)
					corner (2 * Width) (-top)
					corner (2 * Width) (top)
					corner RightSB top

				dispiro
					flat (RightSB - OX) yHookDepth [widths.rhs.heading hookTerminalWidth Downward]
					curl (RightSB - OX) (yHookDepth - yHookStraightDepth) [heading Downward]
					arcvh
					g2.left.mid (RightSB - xHookDepth) O [widths.rhs.heading Stroke Leftward]
					flat [mix (RightSB - xHookDepth) SB kBot] (kBot * yTailDepth)
					curl SB                                   (yTailDepth)

		if (mode != MODE-RTAIL) : begin
			set-base-anchor "trailing" (RightSB - 0.55 * xHookDepth) 0

	define [ZCursiveShape mode]         : ZCursiveShapeImpl CAP mode
	define [SmallZCursiveShape mode]    : ZCursiveShapeImpl XH mode

	define [NoBottomStrokeMask top] : glyph-proc
	define [CurlyBottomStrokeMask top] : spiro-outline
		corner 0 0
		corner SB 0
		corner (SB + Stroke) Stroke
		corner 0 Stroke

	define [DTailBottomStroke] : dispiro
		widths.lhs
		flat SB 0 [heading Rightward]
		curl (RightSB - HookX) 0
		archv
		straight.down.end RightSB (-Hook) [widths.heading 0 Stroke Downward]

	define [SwashBottomStroke] : dispiro
		widths.lhs
		g4 SB 0
		alsoThru 0.36 0.6 important
		flat (RightSB - 1) Descender
		curl RightSB Descender

	define [ZemlyaBottomStroke] : begin
		local fine : AdviceStroke 4
		local hx : [Math.max (0.5 * HookX) (fine * 1.25 * HVContrast)] + (0.125 * HVContrast * fine)
		return : dispiro
			widths.lhs
			flat SB 0 [heading Rightward]
			curl (RightSB - hx) 0
			archv
			g4.down.mid (RightSB - O - HVContrast * fine) [mix (Descender + fine) 0 0.5] [widths.lhs.heading fine {.x HVContrast .y (-(fine - Stroke) / fine)}]
			arcvh
			g2.left.mid (RightSB - hx) (Descender + fine + O)
			alsoThru 0.5 0.5 [widths.center fine]
			g2.left.mid (SB + hx) ([mix Descender 0 0.75] - fine) [widths.rhs fine]
			archv
			g4.down.end (SB + O + HVContrast * fine) Descender [heading Downward]

	define [ZemlyaBottomStrokeCursive] : begin
		local fine : AdviceStroke 4
		local hx : [Math.max (0.5 * HookX) (fine * 1.25 * HVContrast)] + (0.125 * HVContrast * fine)
		return : dispiro
			flat (RightSB - HVContrast * fine) HalfStroke [widths.lhs.heading fine Downward]
			curl (RightSB - HVContrast * fine) [mix (Descender + fine) 0 0.5] [widths.lhs.heading fine Downward]
			arcvh
			g2.left.mid (RightSB - hx) (Descender + fine + O)
			alsoThru 0.5 0.5 [widths.center fine]
			g2.left.mid (SB + hx) ([mix Descender 0 0.75] - fine) [widths.rhs fine]
			archv
			g4.down.end (SB + O + HVContrast * fine) Descender [heading Downward]

	define ZConfig : SuffixCfg.weave
		object # Body
			straight  { ZBaseShape    SmallZBaseShape    NoBottomStrokeMask    }
			curly     { ZCurlyShape   SmallZCurlyShape   CurlyBottomStrokeMask }
			cursive   { ZCursiveShape SmallZCursiveShape NoBottomStrokeMask    }
		object # Serifs
			""            { ZSerifless     } # for Cursive
			serifless     { ZSerifless     }
			serifed       { ZStdSerifs     }
			bottomSerifed { ZMotionSerifsB }
			topSerifed    { ZMotionSerifsT }
		object # overlay
			""                     { null       }
			withCrossBar           { DBarOver   }
			withHorizontalCrossBar { HBar.mOver }

	foreach { suffix { {capital small bsMask} {serifs} {slash} } } [pairs-of ZConfig] : do
		create-glyph "Z.\(suffix)" : glyph-proc
			include : MarkSet.capital
			include : capital MODE-Z
			if serifs : include : serifs CAP
			if slash  : include : slash  CAP

		create-glyph "Z/rtailBase.\(suffix)" : glyph-proc
			include : MarkSet.capital
			include : capital MODE-RTAIL
			if serifs : include : serifs CAP
			if slash  : include : slash  CAP

		create-glyph "ZDTail.\(suffix)" : glyph-proc
			include : MarkSet.capDesc
			include : capital MODE-ZDESC
			if serifs : include : serifs CAP
			if slash  : include : slash  CAP
			eject-contour 'serifRB'
			include : difference [DTailBottomStroke] [bsMask CAP]

		create-glyph "cyrl/Zemlya.\(suffix)" : glyph-proc
			include : MarkSet.capital
			include : ExtendBelowBaseAnchors Descender
			if (capital === ZCursiveShape)
			: then : begin
				include : capital MODE-RTAIL
				if serifs : include : serifs CAP
				if slash  : include : slash  CAP
				include : ZemlyaBottomStrokeCursive
			: else : begin
				include : capital MODE-ZDESC
				if serifs : include : serifs CAP
				if slash  : include : slash  CAP
				eject-contour 'serifRB'
				include : difference [ZemlyaBottomStroke] [bsMask CAP]

		create-glyph "ZSwash.\(suffix)" : glyph-proc
			include : MarkSet.capDesc
			include : capital MODE-ZSWASH
			if serifs : include : serifs CAP
			if slash  : include : slash  CAP
			eject-contour 'serifRB'
			include : difference [SwashBottomStroke] [bsMask CAP]

		create-glyph "z.\(suffix)" : glyph-proc
			include : MarkSet.e
			include : small MODE-Z
			if serifs : include : serifs XH
			if slash  : include : slash  XH

		create-glyph "z/rtailBase.\(suffix)" : glyph-proc
			include : MarkSet.e
			include : small MODE-RTAIL
			if serifs : include : serifs XH
			if slash  : include : slash  XH

		create-glyph "zDTail.\(suffix)" : glyph-proc
			include : MarkSet.p
			include : small MODE-ZDESC
			if serifs : include : serifs XH
			if slash  : include : slash  XH
			eject-contour 'serifRB'
			include : difference [DTailBottomStroke] [bsMask XH]

		create-glyph "cyrl/zemlya.\(suffix)" : glyph-proc
			include : MarkSet.e
			include : ExtendBelowBaseAnchors Descender
			if (small === SmallZCursiveShape)
			: then : begin
				include : small MODE-RTAIL
				if serifs : include : serifs XH
				if slash  : include : slash  XH
				include : ZemlyaBottomStrokeCursive
			: else : begin
				include : small MODE-ZDESC
				if serifs : include : serifs XH
				if slash  : include : slash  XH
				eject-contour 'serifRB'
				include : difference [ZemlyaBottomStroke] [bsMask XH]

		create-glyph "zSwash.\(suffix)" : glyph-proc
			include : MarkSet.p
			include : small MODE-ZSWASH
			if serifs : include : serifs XH
			if slash  : include : slash  XH
			eject-contour 'serifRB'
			include : difference [SwashBottomStroke] [bsMask XH]

		create-glyph "zCurlyTail.\(suffix)" : glyph-proc
			include : MarkSet.e
			include : small MODE-ZDESC
			if serifs : include : serifs XH
			if slash  : include : slash  XH
			eject-contour 'serifRB'
			local fine : AdviceStroke2 5 4 XH
			local rinner : Math.max (XH * 0.04) (fine * 0.1)
			local x2 : mix (SB + Stroke) RightSB 0.3
			local x1 : mix x2 (RightSB - fine - rinner * 1.5) 0.45
			local y2 : -XH * 0.2
			local m1 : RightSB - fine / 2 - rinner * 1.5 + O
			include : difference
				HCurlyTail fine Stroke rinner SB m1 (RightSB + fine / 2) x1 x2 y2
				bsMask XH

	select-variant 'Z' 'Z'
	link-reduced-variant 'Z/sansSerif' 'Z' MathSansSerif
	link-reduced-variant 'Z/reduced' 'Z'
	link-reduced-variant 'Z/reduced/sansSerif' 'Z'
	select-variant 'Z/rtailBase' (follow -- 'Z')

	select-variant 'smcpZ' 0x1D22 (shapeFrom -- 'z') (follow -- 'Z')

	select-variant 'z' 'z'
	link-reduced-variant 'z/sansSerif' 'z' MathSansSerif
	link-reduced-variant 'z/reduced' 'z'
	select-variant 'z/rtailBase' (follow -- 'z')

	select-variant 'ZDTail' 0x224 (follow -- 'ZDesc')
	select-variant 'zDTail' 0x225 (follow -- 'zDesc')
	select-variant 'ZSwash' 0x2C7F (follow -- 'ZDesc')
	select-variant 'zSwash' 0x240 (follow -- 'zDesc')
	select-variant 'zCurlyTail' 0x291 (follow -- 'zDesc')
	select-variant 'cyrl/Zemlya' 0xA640 (follow -- 'ZDesc')
	select-variant 'cyrl/zemlya' 0xA641 (follow -- 'zDesc')
	select-variant 'cyrl/Zemlya/reduced' (follow -- 'ZDesc/reduced') (shapeFrom -- 'cyrl/Zemlya')
	select-variant 'cyrl/zemlya/reduced' (follow -- 'zDesc/reduced') (shapeFrom -- 'cyrl/zemlya')

	derive-composites 'ZDesc'        0x2C6B 'Z/rtailBase' [CyrDescender.r RightSB 0]
	derive-composites 'zDesc'        0x2C6C 'z/rtailBase' [CyrDescender.r RightSB 0]

	derive-composites 'ZPalatalHook' 0xA7C6 'Z/rtailBase' [PalatalHook.r RightSB 0]
	derive-composites 'zPalatalHook' 0x1D8E 'z/rtailBase' [PalatalHook.r RightSB 0]

	derive-composites 'zRTailBR'     0x290  'z/rtailBase' [RetroflexHook.r RightSB 0]

	alias 'grek/Zeta' 0x396 'Z/reduced'
	alias-reduced-variant 'grek/Zeta/sansSerif' 'grek/Zeta' 'Z/reduced/sansSerif' MathSansSerif

	define [BBZShape top] : glyph-proc
		include : HBar.t SB RightSB top BBS
		include : HBar.b SB RightSB 0 BBS
		include : intersection
			Rect top 0 SB RightSB
			union
				dispiro
					widths.center BBS
					corner SB (BBS / 2)
					corner (RightSB - BBD) (top - BBS / 2)
				dispiro
					widths.center BBS
					corner (SB + BBD) (BBS / 2)
					corner RightSB (top - (BBS / 2))

		include : intersection
			union
				VBar.r RightSB (top - BBS * 2) top BBS
				VBar.l  SB 0 (BBS * 2) BBS
			spiro-outline
				corner SB (BBS / 2)
				corner (RightSB - BBD) (top - BBS / 2)
				corner RightSB (top - (BBS / 2))
				corner (SB + BBD) (BBS / 2)

	create-glyph 'mathbb/Z' 0x2124  : composite-proc [MarkSet.capital] [BBZShape CAP]
	create-glyph 'mathbb/z' 0x1D56B : composite-proc [MarkSet.e] [BBZShape XH]


	CreateAccentedComposition 'ZBar' 0x1B5 'Z/reduced' 'barOver'
	CreateAccentedComposition 'zBar' 0x1B6 'z/reduced' 'barOver'
	CreateAccentedComposition 'zTildeOver' 0x1D76 'z/reduced' 'tildeOverWide2'
	CreateAccentedComposition 'ZCaron' 0x17D 'Z' 'caronAbove' true
	CreateAccentedComposition 'zCaron' 0x17E 'z' 'caronAbove' true
	CreateAccentedComposition 'cyrl/ZemlyaBar' 0xA642 'cyrl/Zemlya/reduced' 'barOver'
	CreateAccentedComposition 'cyrl/zemlyaBar' 0xA643 'cyrl/zemlya/reduced' 'barOver'
